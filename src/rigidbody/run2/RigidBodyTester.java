package rigidbody.run2;

import java.awt.BorderLayout;
import java.awt.GraphicsConfiguration;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.Transform3D;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;

import _math.Quaternion;
import _math.Vector3D;

import com.sun.j3d.utils.universe.SimpleUniverse;

/**
 * a class for testing the <code>RigidBody</code> library of this physics engine
 */
public class RigidBodyTester extends JFrame {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/*
	//DEBUG
	public static void main( String[] args ) {
		@SuppressWarnings("unused")
		RigidBodyTester frame = new RigidBodyTester();
	}//*/
	
	
	protected SimpleUniverse m_universe;
	protected RigidBodyTesterCube m_cube;
	
	protected BranchGroup m_group = new BranchGroup();
	
	private int m_eyeX = 0;
	private int m_eyeY = 97;
	private int m_eyeZ = -10;
	
	/**
	 * creates an Applet that can be used to test the <code>RigidBody</code>
	 * library using Java3D
	 */
	public RigidBodyTester() {
		setLayout( new BorderLayout() );
		GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
		Canvas3D canvas = new Canvas3D( config );
		JPanel pnlCanvas = new JPanel( new BorderLayout() );
		pnlCanvas.add( canvas , BorderLayout.CENTER );
		this.add( pnlCanvas , BorderLayout.CENTER );
		
		BranchGroup content = createScene();
		content.compile();
		
		this.m_universe = new SimpleUniverse( canvas );
		Transform3D move = lookFromPointToPoint( new Point3d( this.m_eyeX , this.m_eyeY , this.m_eyeZ ) , new Point3d( this.m_eyeX , this.m_eyeY , this.m_eyeZ + 5 ) );
		updateEye( move );
		this.m_universe.addBranchGraph( content );
		
		pnlCanvas.setFocusable( true );
		pnlCanvas.addKeyListener( new RigidBodyTestKeyListener() );
		
		setSize(500, 500);
		setVisible(true);
		setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	}
	
	/**
	 * @return			a <code>BranchGroup</code> set up with all necessary component, e.g. cubes, spheres,
	 * 					that are to be part of the scene
	 */
	public BranchGroup createScene() {
		this.m_cube = new RigidBodyTesterCube();
		this.m_group.addChild( this.m_cube.getTransformGroup() );
		return this.m_group;
	}
	
	public void updateCube( Vector3D newPosition, Quaternion newOrientation ) {
		this.m_cube.drawCube( newPosition , newOrientation );
	}

	

	/**
	 * sets the view at <code>observationPoint</code> to look towards <code>targetPoint</code>
	 * 
	 * @param observationPoint			the location of the observer
	 * @param targetPoint				the location to which the observer looks
	 * @return							a <code>Transform3D</code> that can be used to modify the view to
	 * 									be at the observation point looking at the target point
	 */
	public static Transform3D lookFromPointToPoint( Point3d observationPoint , Point3d targetPoint ) {
		Transform3D move = new Transform3D();
		Vector3d up = new Vector3d( observationPoint.x , observationPoint.y + 1 , observationPoint.z );
		move.lookAt( observationPoint , targetPoint , up );
		move.invert();
		return move;
	}
	
	/**
	 * modifies the view position given a new position. the parameter for this method
	 * is generated by <code>lookFromPointToPoint</code>
	 * 
	 * @param eyePosition			the new position for the view
	 * @see 						#lookFromPointToPoint(Point3d, Point3d)
	 */
	public void updateEye( Transform3D eyePosition ) {
		this.m_universe.getViewingPlatform().getViewPlatformTransform().setTransform( eyePosition );
	}
	
	public void updateEye() {
		Transform3D move = lookFromPointToPoint( new Point3d( this.m_eyeX , this.m_eyeY , this.m_eyeZ ) , new Point3d( this.m_eyeX , this.m_eyeY , this.m_eyeZ + 5 ) );
		updateEye( move );
	}
	
	public void moveForward() {
		this.m_eyeZ ++;
		updateEye();
	}
	
	public void moveBackward() {
		this.m_eyeZ --;
		updateEye();
	}
	
	public void moveLeft() {
		this.m_eyeX ++;
		updateEye();
	}
	
	public void moveRight() {
		this.m_eyeX --;
		updateEye();
	}
	
	public void moveUp() {
		this.m_eyeY ++;
		updateEye();
	}
	
	public void moveDown() {
		this.m_eyeY --;
		updateEye();
	}
	
	public void handleKeyPressed( int keyCode ) {
		if ( keyCode == KeyEvent.VK_W ) {
			moveForward();
		} else if ( keyCode == KeyEvent.VK_S ) {
			moveBackward();
		} else if ( keyCode == KeyEvent.VK_A ) {
			moveLeft();
		} else if ( keyCode == KeyEvent.VK_D ) {
			moveRight();
		} else if ( keyCode == KeyEvent.VK_UP ) {
			moveUp();
		} else if ( keyCode == KeyEvent.VK_DOWN ) {
			moveDown();
		}
	}
	
	protected class RigidBodyTestKeyListener implements KeyListener {

		public RigidBodyTestKeyListener() {
			
		}
		
		@Override
		public void keyPressed(KeyEvent e) {
			handleKeyPressed( e.getKeyCode() );
		}

		@Override
		public void keyReleased(KeyEvent arg0) {
			//ignore
		}

		@Override
		public void keyTyped(KeyEvent arg0) {
			//ignore
		}
		
	}
}
